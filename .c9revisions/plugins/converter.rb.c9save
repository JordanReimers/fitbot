{"ts":1359009909575,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1359010349767,"patch":[[{"diffs":[[1,"# encoding: utf-8\n\nEncoding.default_external = \"UTF-8\"\nEncoding.default_internal = \"UTF-8\"\n\nrequire 'mathn'\n\nclass Wilks\n    include Cinch::Plugin\n    \n    listen_to :channel\n    def listen(m)\n        unless m.message =~ /^\\.?convert/ || m.message =~ /^\\.?r?wilks/\n    \t\tanswer = {}\n\t\t\t#If the message includes pounds or kilograms\n\t\t\tif m.message =~ /\\b(?:(?<!-)|(?=\\.))(?:((?:\\d+(?:,\\d+)*)?(?:\\.|,)?\\d+)\\s*\\s*-\\s*)?((?:\\d+(?:,\\d+)*)?(?:\\.)?\\d+)\\s*((?:pound|kilo(?:\\s*gram)?|lb|kg|#)s?)(?:\\b|(?<=#))/i\n\t\t\t\tweights = m.message.scan(/\\b(?:(?<!-)|(?=\\.))(?:((?:\\d+(?:,\\d+)*)?(?:\\.|,)?\\d+)\\s*\\s*-\\s*)?((?:\\d+(?:,\\d+)*)?(?:\\.)?\\d+)\\s*((?:pound|kilo(?:\\s*gram)?|lb|kg|#)s?)(?:\\b|(?<=#))/i)\n\t\t\t\tanswer[:weights]= Convert.parse_weights_from_channel(weights)\n\t\t\tend\n\t\t\t#When the message includes the word 'plate' (1 plate -> 135lb, 60kg)\n\t\t\tif m.message =~ /\\b(?<!\\.)(\\d+|[a-z]+)-?\\s?plates?/i\n\t\t\t\tplates = m.message.scan(/\\b(?<!\\.)(\\d+|[a-z]+)-?\\s?plates?/i)\n\t\t\t\tanswer[:plates]= plates.map { |(num)|\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnum = Numeral.parse_num(num)\n\t\t\t\t\t\t\"#{num}-plate => #{Float(num)*(2*45)+45} lbs, #{Float(num)*(2*20)+20} kgs\"\n\t\t\t\t\trescue Exception\n\t\t\t\t\t\t# ignored\n\t\t\t\t\tend\n\t\t\t\t}.join(\" | \")\n\t\t\tend\n\t\t\t#If m.message contains feet|inches\n\t\t\tif m.message =~ /\\b(\\d*\\.?\\d+)\\s*(?:ft|feet)(?:\\s*(\\d+)\\s*(?:in|inches))?\\b|\\b(\\d*\\.?\\d+)(?:')(?:(\\d+)(?:\")?)?/i\n\t\t\t\tfeet = m.message.scan /\\b(\\d*\\.?\\d+)\\s*(?:ft|feet)(?:\\s*(\\d+)\\s*(?:in|inches))?\\b|\\b(\\d*\\.?\\d+)(?:')(?:(\\d+)(?:\")?)?/i\n\t\t\t\tanswer[:feet]= feet.map { |a, b, c, d|\n\t\t\t\t\tbegin\n\t\t\t\t\t\ta,b = c,d if (a.nil? and b.nil?)\n\t\t\t\t\t\toriginal = b.nil? ? \"#{a}'\" : \"#{a}'#{b}\\\"\"\n\t\t\t\t\t\tans = original.unit >> \"meters\"\n\t\t\t\t\t\t\"#{original} => #{ans.scalar.to_f.round(3)} #{ans.units}\"\n\t\t\t\t\trescue Exception\n\t\t\t\t\t\t# ignored\n\t\t\t\t\tend\n\t\t\t\t}.join(\" | \")\n\t\t\tend\n\t\t\t#If m.message contains meters\n\t\t\tif m.message =~ /\\b(\\d*\\.?\\d+)\\s*m(?:eters?)?\\b/i\n\t\t\t\tmeters = m.message.scan /(\\d*\\.?\\d+)\\s*m(?:eters?)?\\b/i\n\t\t\t\tanswer[:meters]= meters.map { |(a)| #Why needs a ()?\n\t\t\t\t\tbegin\n\t\t\t\t\t\toriginal = \"#{a} m\"\n\t\t\t\t\t\t\"#{original} => #{original.unit.to_s(:ft)}\"\n\t\t\t\t\trescue Exception => e\n\t\t\t\t\t\te.message\n\t\t\t\t\tend\n\t\t\t\t}.join(\" | \")\n\t\t\tend\n\t\t\tm.reply answer.values.join(\" | \")\n\t\tend\n    end\n  end\nend"]],"start1":0,"start2":0,"length1":0,"length2":2213}]],"length":2213,"saved":false}
{"ts":1359010491961,"patch":[[{"diffs":[[0,"  end\n  "],[1,"  \n    module Convert\n    \tdef self.to_kg(num)\n\t\t\t(Float(num)/2.2).round(3)\n\t\tend\n\n\t\tdef self.to_lb(num)\n\t\t\t(Float(num)*2.2).round(3)\n\t\tend\n\n\t\tdef self.parse(expression)\n\t\t\texpression = expression.sub(/\\bto\\b/, \"\")\n\t\t\tcase expression\n\t\t\t\twhen /\\s*(.+)?\\s+(.+)/\n\t\t\t\t\tfrom = $1\n\t\t\t\t\tto = $2\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif to.unit.units == \"ft\"\n\t\t\t\t\t\t\t\"#{from}\".unit.to_s(:ft)\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tans = \"#{from}\".unit >> \"#{to}\"\n\t\t\t\t\t\t\t\"#{ans.scalar.to_f} #{ans.units}\"\n\t\t\t\t\t\tend\n\t\t\t\t\trescue Exception\n\t\t\t\t\t\t\"Undefined conversion\"\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\t\"Undefined conversion\"\n\t\t\tend\n\t\tend\n\n\t\tdef self.parse_weights_from_channel(weights)\n\t\t\tweights.map { |a, b, unit| #|weight,index|\n\n\t\t\t\ta = a.gsub(/,/, \"\") unless a.nil?\n\t\t\t\tb = b.gsub(/,/, \"\")\n\n\t\t\t\tnew_unit = (unit =~ /(?:pound|lb|#)s?/i) ? \"kg\" : \"lb\"\n\t\t\t\tunit = (new_unit == \"kg\") ? \"lb\" : \"kg\"\n\n\t\t\t\tcase unit\n\t\t\t\t\twhen \"kg\"\n\t\t\t\t\t\tnew_a = Convert.to_lb a unless a.nil?\n\t\t\t\t\t\tnew_b = Convert.to_lb b\n\t\t\t\t\twhen \"lb\"\n\t\t\t\t\t\tnew_a = Convert.to_kg a unless a.nil?\n\t\t\t\t\t\tnew_b = Convert.to_kg b\n\t\t\t\t\telse\n\t\t\t\t\t\t# should never reach here\n\t\t\t\tend\n\n\t\t\t\tif a.nil?\n\t\t\t\t\t\"#{b} #{unit} => #{new_b} #{new_unit}\"\n\t\t\t\telse\n\t\t\t\t\t\"#{a}-#{b} #{unit} => #{new_a}-#{new_b} #{new_unit}\"\n\t\t\t\tend\n\n\t\t\t}.join(\" | \")\n\t\tend\n\t"],[0,"end\nend"]],"start1":2198,"start2":2198,"length1":15,"length2":1252}]],"length":3450,"saved":false}
{"ts":1359010522456,"patch":[[{"diffs":[[0,"hn'\n"],[-1,"\nclass Wilks"],[1,"require 'ruby-units'\n\nclass Converter"],[0,"\n   "]],"start1":104,"start2":104,"length1":20,"length2":45}]],"length":3475,"saved":false}
{"ts":1359010677342,"patch":[[{"diffs":[[0,"   end\n    \n"],[1,"    module Numeral\n    \tdef self.parse_num(text)\n\t\t\treturn nil unless text\n\t\t\treturn nil if text.length == 0\n\t\t\treturn parse_natural_num(text) if text[/[a-z|A-Z]/]\n\t\t\tnumerator, denominator = text.split('/')\n\t\t\treturn numerator.to_f if numerator.include?('.')\n\t\t\treturn numerator.to_i if denominator.nil?\n\t\t\tdenominator ||= 1\n\t\t\tRational(numerator.to_i, denominator.to_i)\n\t\tend\n\n\t\tdef self.parse_natural_num(text)\n\t\t\t%w(zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty).index(text.downcase)\n\t\tend\n\tend\n    \n"],[0,"    module C"]],"start1":2222,"start2":2222,"length1":24,"length2":619}]],"length":4070,"saved":false}
{"contributors":[],"silentsave":false,"ts":1367010414140,"patch":[[{"diffs":[[0,"\n\t\t\tend\n"],[1,"            #If m.message contains cm\n            if m.message =~ /\\b(\\d*\\.?\\d+)\\s*c(?:enti)?m(?:eters?)?\\b/i\n                centimeters = m.message.scan /\\b(\\d*\\.?\\d+)\\s*c(?:enti)?m(?:eters?)?\\b/i\n    \t\t\tanswer[:centimeters]= centimeters.map { |(a)| #Why needs a ()?\n\t\t\t\t\tbegin\n\t\t\t\t\t\toriginal = \"#{a} cm\"\n\t\t\t\t\t\t\"#{original} => #{original.unit.to_s(:ft)}\"\n\t\t\t\t\trescue Exception => e\n\t\t\t\t\t\te.message\n\t\t\t\t\tend\n\t\t\t\t}.join(\" | \")\n            end\n            #If m.message contains stone\n            if m.message =~ /\\b(\\d*\\.?\\d+)\\s*stone\\b/i\n                stone = m.message.scan /\\b(\\d*\\.?\\d+)\\s*stone\\b/i\n        \t\tanswer[:stone]= stone.map { |(a)| #Why needs a ()?\n\t\t\t\t\tbegin\n\t\t\t\t\t\toriginal = \"#{a} stone\"\n\t\t\t\t\t\t\"#{original} => #{original.unit.to_s(:ft)}\"\n\t\t\t\t\trescue Exception => e\n\t\t\t\t\t\te.message\n\t\t\t\t\tend\n\t\t\t\t}.join(\" | \")\n            end\n"],[0,"\t\t\tm.rep"]],"start1":2170,"start2":2170,"length1":16,"length2":859}]],"length":4913,"saved":false}
{"ts":1367010823378,"patch":[[{"diffs":[[0,"inal.unit.to_s(:"],[-1,"ft"],[1,"kg"],[0,")}\"\n\t\t\t\t\trescue "]],"start1":2913,"start2":2913,"length1":34,"length2":34}]],"length":4913,"saved":false}
{"contributors":[],"silentsave":false,"ts":1367011403167,"patch":[[{"diffs":[[0,"d+)\\s*stone\\b/i\n"],[1,"                jokeUnits = {\"feathers\",\"cigarrettes\",\"moms\",\"boobies\",\"faggots\",\"trees\"}\n"],[0,"                "]],"start1":2701,"start2":2701,"length1":32,"length2":122},{"diffs":[[0,"> #{"],[-1,"original.unit.to_s(:kg)"],[1,"rand(5000)} #{jokeUnits[rand(jokeUnits.length)]"],[0,"}\"\n\t"]],"start1":2995,"start2":2995,"length1":31,"length2":55}]],"length":5027,"saved":false}
